# Project: MicroTCP (CS-335a)

**Φοιτητές:**
* **Μιχάλης Φαρδέλλας** (csd5250)
* **Δημήτρης Μπίρος** (csd5218)

## Εισαγωγή

Στα πλαίσια του μαθήματος CS-335a, υλοποιήσαμε το `microTCP`, μια "lightweight" εκδοχή του πρωτοκόλλου TCP που τρέχει πάνω από UDP. Στόχος μας ήταν να προσομοιώσουμε τις βασικές λειτουργίες αξιοπιστίας, όπως το connection establishment (3-way handshake), τον έλεγχο ακεραιότητας πακέτων (checksums) και τη σωστή διαχείριση της ροής δεδομένων.

Παρακάτω ακολουθεί μια **αναλυτική επεξήγηση** της δομής και της λογικής πίσω από κάθε συνάρτηση που γράψαμε στο `lib/microtcp.c`, ώστε να είναι ξεκάθαρο το πώς σκεφτήκαμε και πώς λύσαμε τα προβλήματα που προέκυψαν.

---

## Ανάλυση Υλοποίησης (Library Internals)

Ο πυρήνας της εργασίας βρίσκεται στο αρχείο `lib/microtcp.c`. Εδώ έχουμε υλοποιήσει όλη τη λογική του πρωτοκόλλου.

### Helper Functions

#### `microtcp_seed_rand()`
Επειδή η ασφάλεια και η μοναδικότητα των συνδέσεων ξεκινάει από τα Sequence Numbers (ISN), φτιάξαμε αυτή τη μικρή helper συνάρτηση. Εξασφαλίζει ότι η `srand()` θα κληθεί **μόνο μία φορά** (χρησιμοποιώντας ένα static flag), ώστε τα τυχαία νούμερα που παράγουμε για τα SEQ numbers να είναι διαφορετικά σε κάθε εκτέλεση, βασισμένα στον χρόνο (`time(NULL)`).

#### `microtcp_send_packet()`
Αυτή είναι η συνάρτηση "εργάτης" για την αποστολή. Αντί να γράφουμε κώδικα αποστολής παντού, τα περνάμε όλα από εδώ.
1.  Δεσμεύουμε μνήμη για το header και το payload.
2.  **Checksum Calculation:** Πριν στείλουμε το πακέτο, μηδενίζουμε το πεδίο `checksum` και καλούμε την `crc32()` (από το `utils/crc32.h`) για να υπολογίσουμε το CRC ολόκληρου του πακέτου. Αυτό είναι κρίσιμο για να ξέρει ο παραλήπτης αν το πακέτο έφτασε αλλοιωμένο.
3.  Τέλος, στέλνουμε το πακέτο μέσω της `sendto()` (UDP) στην αποθηκευμένη διεύθυνση του peer.

#### `microtcp_validate_packet()`
Το αντίστροφο του παραπάνω. Όταν λαμβάνουμε ένα πακέτο, δεν το εμπιστευόμαστε αμέσως:
1.  Κρατάμε το checksum που ήρθε στο header.
2.  Μηδενίζουμε το πεδίο στο header (όπως ήταν πριν τον υπολογισμό).
3.  Ξανατρέχουμε τον αλγόριθμο CRC32.
4.  Αν το αποτέλεσμα δεν ταιριάζει με αυτό που λάβαμε, το πακέτο είναι corrupted και το απορρίπτουμε (`return -1`).

---

### Core API Functions

#### `microtcp_socket()`
Εδώ γίνεται η αρχικοποίηση του connection structure (`microtcp_sock_t`).
* Ανοίγουμε το πραγματικό UDP socket.
* Θέτουμε το state σε `CLOSED`.
* Αρχικοποιούμε τις τιμές για το Congestion Window (`cwnd`), το `ssthresh` και τα window sizes στις default τιμές που ορίστηκαν στο header file (`MICROTCP_INIT_CWND` κλπ), ώστε να είμαστε έτοιμοι για τη σύνδεση.

#### `microtcp_bind()`
Η συνάρτηση αυτή προετοιμάζει τον server.
* Κάνει bind το UDP socket στην τοπική πόρτα.
* Αλλάζει το state σε `LISTEN`.
* **Σημαντικό:** Εδώ δεσμεύουμε τον `recvbuf`. Αποφασίσαμε να το κάνουμε εδώ για να είναι έτοιμος ο buffer να υποδεχτεί δεδομένα μόλις ολοκληρωθεί το handshake.

#### `microtcp_connect()` (Client-side 3-Way Handshake)
Εδώ υλοποιήσαμε βήμα-βήμα το κλασικό TCP handshake για τον Client:
1.  **SYN:** Επιλέγουμε τυχαίο `seq_number`, ενεργοποιούμε το `MICROTCP_FLAG_SYN` και στέλνουμε το πρώτο πακέτο.
2.  **Wait for SYN/ACK:** Μπλοκάρουμε περιμένοντας απάντηση. Μόλις έρθει, κάνουμε validate το checksum και ελέγχουμε αν έχει τα flags SYN και ACK ενεργά. Ελέγχουμε επίσης αν το `ack_number` που λάβαμε ισούται με το `seq_number + 1` (επιβεβαίωση).
3.  **ACK:** Αν όλα είναι καλά, ενημερώνουμε τα δικά μας sequence/ack numbers, θέτουμε το state σε `ESTABLISHED` και στέλνουμε το τελικό ACK στον server.

#### `microtcp_accept()` (Server-side 3-Way Handshake)
Η πλευρά του Server. Η λογική είναι αντίστοιχη:
1.  Περιμένουμε (`recvfrom`) ένα πακέτο με `SYN`.
2.  Μόλις έρθει και είναι έγκυρο, αποθηκεύουμε τα στοιχεία του Client (`peer_addr`).
3.  Στέλνουμε πίσω **SYN/ACK** (με δικό μας τυχαίο seq και ack = client_seq + 1).
4.  Περιμένουμε το τελικό **ACK** από τον Client.
5.  Μόλις ολοκληρωθεί, μπαίνουμε σε state `ESTABLISHED` και είμαστε έτοιμοι για ανταλλαγή δεδομένων.

#### `microtcp_shutdown()` (Connection Teardown)
Για το κλείσιμο της σύνδεσης, υλοποιήσαμε τη διαδικασία FIN.
* Στέλνουμε πακέτο με `MICROTCP_FLAG_FIN`.
* Περιμένουμε για `FIN/ACK`.
* Στέλνουμε το τελικό `ACK` για να επιβεβαιώσουμε το κλείσιμο.
* Αποδεσμεύουμε τη μνήμη (`recvbuf`) και κλείνουμε τον file descriptor.
* Αυτό διασφαλίζει ότι δεν μένουν "zombie" sockets ή memory leaks.

#### `microtcp_send()` (Data Transmission)
Εδώ διαχειριζόμαστε την αποστολή των δεδομένων.
* Χωρίζουμε τα δεδομένα σε κομμάτια μεγέθους **MSS** (`MICROTCP_MSS`). Δεν στέλνουμε ποτέ πακέτο μεγαλύτερο από αυτό για να αποφύγουμε IP fragmentation.
* Για κάθε κομμάτι, φτιάχνουμε header, βάζουμε το σωστό Sequence Number και το στέλνουμε.
* Αυξάνουμε τα στατιστικά (`bytes_send`, `packets_send`) και ενημερώνουμε το `seq_number` του socket για την επόμενη κλήση.

#### `microtcp_recv()` (Data Reception)
Η συνάρτηση που καλεί η εφαρμογή για να διαβάσει δεδομένα.
1.  Δεσμεύουμε προσωρινό buffer για να χωράει Header + Payload.
2.  Κάνουμε `recvfrom` και `validate_packet`.
3.  **Διαχείριση FIN:** Αν το πακέτο έχει `FIN` flag, τότε ξεκινάμε τη διαδικασία τερματισμού από την πλευρά του δέκτη (στέλνουμε FIN/ACK, περιμένουμε ACK, κλείνουμε).
4.  **Διαχείριση Data:** Αν είναι data packet, αντιγράφουμε το payload στο buffer που μας έδωσε ο χρήστης (προσέχοντας να μην κάνουμε buffer overflow ελέγχοντας το `length`).
5.  Στέλνουμε/Ενημερώνουμε το `ack_number` ώστε ο αποστολέας να ξέρει ότι παραλάβαμε τα bytes.

---

## Utils & Tests

Στον φάκελο `utils/` συμπεριλάβαμε το `crc32.h` που περιέχει την υλοποίηση του αλγορίθμου CRC-32 με lookup tables για ταχύτητα.

Στον φάκελο `test/` φτιάξαμε διάφορα σενάρια για να τεστάρουμε τον κώδικά μας:
* `test_microtcp_server.c` & `test_microtcp_client.c`: Ένα απλό Echo Server/Client παράδειγμα για να επιβεβαιώσουμε ότι το handshake και η αποστολή μηνυμάτων δουλεύουν σωστά.
* `bandwidth_test.c`: Εργαλείο για μετρήσεις απόδοσης (throughput) κατά τη μεταφορά αρχείων.
* `traffic_generator.cpp` & `traffic_generator_client.c`: Για προσομοίωση κίνησης και stress testing του connection.

## Compilation

Για το build system χρησιμοποιήσαμε **CMake** για να είναι cross-platform και εύκολο.

```bash
mkdir build
cd build
cmake ..
make
